{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { Kind } from 'graphql';\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n;\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n  return flavored;\n}\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader, fragments) {\n    this.cache = cache;\n    this.reader = reader;\n    this.fragments = fragments;\n  }\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      variables = _a.variables,\n      overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = __assign(__assign({\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables)\n    }, extractFragmentContext(query, this.fragments)), {\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    });\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n    if (!isReference(ref)) {\n      throw __DEV__ ? new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new InvariantError(7);\n    }\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n        mergeTree = _a.mergeTree,\n        fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          return;\n        }\n        storeObject = applied;\n      }\n      if (__DEV__ && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n      store.merge(dataId, storeObject);\n    });\n    store.retain(ref.__ref);\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    var incoming = Object.create(null);\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n      return policies.readField(options, context);\n    };\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n      var _a;\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n        var childTypename = void 0;\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n        if (merge) {\n          childTree.info = {\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (__DEV__ && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {\n        __DEV__ && invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n      }\n    });\n    try {\n      var _b = policies.identify(result, {\n          typename: typename,\n          selectionSet: selectionSet,\n          fragmentMap: context.fragmentMap,\n          storeObject: incoming,\n          readField: readField\n        }),\n        id = _b[0],\n        keyObject = _b[1];\n      dataId = dataId || id;\n      if (keyObject) {\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      if (!dataId) throw e;\n    }\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n      var previous_1 = context.incomingById.get(dataId);\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n      return dataRef;\n    }\n    return incoming;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false);\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n          deferred = inheritedContext.deferred;\n        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n            }\n          });\n        }\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n          if (existing) {\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw __DEV__ ? new InvariantError(\"No fragment named \".concat(selection.name.value)) : new InvariantError(8);\n          }\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n    return fieldMap;\n  };\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n    var _this = this;\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      var i_1 = incoming;\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n      var changedFields_1;\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n      if (changedFields_1) {\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n    return incoming;\n  };\n  return StoreWriter;\n}();\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}","map":{"version":3,"names":["__assign","invariant","InvariantError","equal","Trie","Kind","getFragmentFromSelection","getDefaultValues","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","isNonEmptyArray","argumentsObjectFromField","isArray","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","extractFragmentContext","canonicalStringify","normalizeReadFieldOptions","getContextFlavor","context","clientOnly","deferred","key","concat","flavored","flavors","get","set","StoreWriter","cache","reader","fragments","prototype","writeToStore","store","_a","_this","query","result","dataId","variables","overwrite","operationDefinition","merger","written","Object","create","merge","existing","incoming","varString","incomingById","Map","ref","processSelectionSet","selectionSet","mergeTree","map","__DEV__","JSON","stringify","forEach","storeObject","fieldNodeSet","entityRef","size","applied","applyMerges","fieldsWithSelectionSets_1","field","name","value","hasSelectionSet_1","storeFieldName","hasMergeFunction_1","childTree","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","typename","rootTypenamesById","fragmentMap","__typename","readField","options","arguments","from","result_1","Set","flattenFields","resultFieldKey","add","getStoreFieldName","fieldName","getChildMergeTree","incomingValue","processFieldValue","childTypename","getMergeFunction","maybeRecycleChildMergeTree","added","getReadFunction","error","substring","_b","identify","id","keyObject","e","dataRef","sets","indexOf","push","isFresh","previous_1","mergeMergeTrees","mergeTreeIsEmpty","item","i","fieldMap","limitingTrie","flatten","inheritedContext","visitedNode","lookup","visited","selections","selection","directives","dir","args","if","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","getFieldValue","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","has","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","warn","length","join"],"sources":["/Users/manjunathbandaru/deploy-graph-angular/node_modules/@apollo/client/cache/inmemory/writeToStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { Kind, } from 'graphql';\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n;\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&\n            context.deferred === deferred) ? context : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));\n    }\n    return flavored;\n}\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map, clientOnly: false, deferred: false, flavors: new Map });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw __DEV__ ? new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new InvariantError(7);\n        }\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    return;\n                }\n                storeObject = applied;\n            }\n            if (__DEV__ && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        var incoming = Object.create(null);\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, field.selectionSet\n                    ? getContextFlavor(context, false, false)\n                    : context, childTree);\n                var childTypename = void 0;\n                if (field.selectionSet &&\n                    (isReference(incomingValue) ||\n                        storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (__DEV__ &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                !policies.getReadFunction(typename, field.name.value)) {\n                __DEV__ && invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n            }\n        });\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            dataId = dataId || id;\n            if (keyObject) {\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return __DEV__ ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false);\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (!(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw __DEV__ ? new InvariantError(\"No fragment named \".concat(selection.name.value)) : new InvariantError(8);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = (!isArray(incoming) &&\n                (isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;\n            var i_1 = incoming;\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return isArray(from)\n                    ? (typeof name === \"number\" ? from[name] : void 0)\n                    : context.store.getFieldValue(from, String(name));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map;\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map :\n        left.map.size ? left.map : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (isReference(existing))\n        return;\n    if (equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!isArray(existing) &&\n        !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length\n        ? \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n        : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}