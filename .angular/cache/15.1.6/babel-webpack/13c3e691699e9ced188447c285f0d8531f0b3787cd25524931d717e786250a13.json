{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from 'graphql';\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: '__typename'\n  }\n};\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(function (selection) {\n    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n  });\n}\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(directives) {\n  var nameSet = new Set();\n  var tests = [];\n  directives.forEach(function (directive) {\n    if (directive.name) {\n      nameSet.add(directive.name);\n    } else if (directive.test) {\n      tests.push(directive.test);\n    }\n  });\n  return function (directive) {\n    return nameSet.has(directive.name.value) || tests.some(function (test) {\n      return test(directive);\n    });\n  };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n  var map = new Map();\n  return function inUseGetterFunction(key) {\n    if (key === void 0) {\n      key = defaultKey;\n    }\n    var inUse = map.get(key);\n    if (!inUse) {\n      map.set(key, inUse = {\n        variables: new Set(),\n        fragmentSpreads: new Set()\n      });\n    }\n    return inUse;\n  };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n  var getInUseByOperationName = makeInUseGetterFunction(\"\");\n  var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n  var getInUse = function (ancestors) {\n    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    __DEV__ && invariant.error(\"Could not find operation or fragment\");\n    return null;\n  };\n  var operationCount = 0;\n  for (var i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n  var directiveMatcher = getDirectiveMatcher(directives);\n  var hasRemoveDirective = directives.some(function (directive) {\n    return directive.remove;\n  });\n  var shouldRemoveField = function (nodeDirectives) {\n    return hasRemoveDirective && nodeDirectives && nodeDirectives.some(directiveMatcher);\n  };\n  var originalFragmentDefsByPath = new Map();\n  var firstVisitMadeChanges = false;\n  var fieldOrInlineFragmentVisitor = {\n    enter: function (node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    }\n  };\n  var docWithoutDirectiveSubtrees = visit(doc, {\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n    VariableDefinition: {\n      enter: function () {\n        return false;\n      }\n    },\n    Variable: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n      }\n    },\n    FragmentDefinition: {\n      enter: function (node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave: function (node, _key, _parent, path) {\n        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n        if (node === originalNode) {\n          return node;\n        }\n        if (operationCount > 0 && node.selectionSet.selections.every(function (selection) {\n          return selection.kind === Kind.FIELD && selection.name.value === '__typename';\n        })) {\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    },\n    Directive: {\n      leave: function (node) {\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    }\n  });\n  if (!firstVisitMadeChanges) {\n    return doc;\n  }\n  var populateTransitiveVars = function (inUse) {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(function (childFragmentName) {\n          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n            inUse.transitiveVars.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n  var allFragmentNamesUsed = new Set();\n  docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  allFragmentNamesUsed.forEach(function (fragmentName) {\n    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n  var fragmentWillBeRemoved = function (fragmentName) {\n    return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n  };\n  var enterVisitor = {\n    enter: function (node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    }\n  };\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    FragmentSpread: enterVisitor,\n    FragmentDefinition: enterVisitor,\n    OperationDefinition: {\n      leave: function (node) {\n        if (node.variableDefinitions) {\n          var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n          if (usedVariableNames_1.size < node.variableDefinitions.length) {\n            return __assign(__assign({}, node), {\n              variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                return usedVariableNames_1.has(varDef.variable.name.value);\n              })\n            });\n          }\n        }\n      }\n    }\n  }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n  return visit(doc, {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {\n          return;\n        }\n        var selections = node.selections;\n        if (!selections) {\n          return;\n        }\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);\n        });\n        if (skip) {\n          return;\n        }\n        var field = parent;\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === 'export';\n        })) {\n          return;\n        }\n        return __assign(__assign({}, node), {\n          selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false)\n        });\n      }\n    }\n  });\n}, {\n  added: function (field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === 'key';\n      })) {\n        __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');\n      }\n    }\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  if (!isField(selection)) {\n    return true;\n  }\n  if (!selection.directives) {\n    return false;\n  }\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n          if (node.arguments) {\n            node.arguments.forEach(function (arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n}\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n  if (definitionOperation === 'query') {\n    return document;\n  }\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: 'query'\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === 'client';\n    },\n    remove: true\n  }], document);\n  return modifiedDoc;\n}","map":{"version":3,"names":["__assign","__spreadArray","invariant","visit","Kind","checkDocument","getOperationDefinition","getFragmentDefinition","getFragmentDefinitions","getMainDefinition","isField","createFragmentMap","isArray","TYPENAME_FIELD","kind","FIELD","name","NAME","value","isEmpty","op","fragmentMap","selectionSet","selections","every","selection","FRAGMENT_SPREAD","nullIfDocIsEmpty","doc","getDirectiveMatcher","directives","nameSet","Set","tests","forEach","directive","add","test","push","has","some","makeInUseGetterFunction","defaultKey","map","Map","inUseGetterFunction","key","inUse","get","set","variables","fragmentSpreads","removeDirectivesFromDocument","getInUseByOperationName","getInUseByFragmentName","getInUse","ancestors","p","ancestor","length","OPERATION_DEFINITION","FRAGMENT_DEFINITION","__DEV__","error","operationCount","i","definitions","directiveMatcher","hasRemoveDirective","remove","shouldRemoveField","nodeDirectives","originalFragmentDefsByPath","firstVisitMadeChanges","fieldOrInlineFragmentVisitor","enter","node","docWithoutDirectiveSubtrees","Field","InlineFragment","VariableDefinition","Variable","_key","_parent","_path","FragmentSpread","FragmentDefinition","path","JSON","stringify","leave","originalNode","removed","Directive","populateTransitiveVars","transitiveVars","childFragmentName","varName","allFragmentNamesUsed","def","fragmentName","fragmentWillBeRemoved","enterVisitor","OperationDefinition","variableDefinitions","usedVariableNames_1","size","filter","varDef","variable","addTypenameToDocument","Object","assign","SelectionSet","parent","skip","lastIndexOf","field","d","added","connectionRemoveConfig","willRemove","arguments","arg","warn","removeConnectionDirectiveFromDocument","hasDirectivesInSelectionSet","nestedCheck","hasDirectivesInSelection","getArgumentMatcher","config","argumentMatcher","argument","aConfig","VARIABLE","removeArgumentsFromDocument","argMatcher","argConfig","argMatchCount_1","Argument","removeFragmentSpreadFromDocument","buildQueryFromSelectionSet","document","definition","definitionOperation","operation","modifiedDoc","removeClientSetsFromDocument"],"sources":["/Users/manjunathbandaru/deploy-graph-angular/node_modules/@apollo/client/utilities/graphql/transform.js"],"sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind, } from 'graphql';\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition, } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap, } from \"./fragments.js\";\nimport { isArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n    kind: Kind.FIELD,\n    name: {\n        kind: Kind.NAME,\n        value: '__typename',\n    },\n};\nfunction isEmpty(op, fragmentMap) {\n    return !op || op.selectionSet.selections.every(function (selection) { return selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap); });\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))\n        ? null\n        : doc;\n}\nfunction getDirectiveMatcher(directives) {\n    var nameSet = new Set();\n    var tests = [];\n    directives.forEach(function (directive) {\n        if (directive.name) {\n            nameSet.add(directive.name);\n        }\n        else if (directive.test) {\n            tests.push(directive.test);\n        }\n    });\n    return function (directive) { return (nameSet.has(directive.name.value) ||\n        tests.some(function (test) { return test(directive); })); };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n    var map = new Map();\n    return function inUseGetterFunction(key) {\n        if (key === void 0) { key = defaultKey; }\n        var inUse = map.get(key);\n        if (!inUse) {\n            map.set(key, inUse = {\n                variables: new Set,\n                fragmentSpreads: new Set,\n            });\n        }\n        return inUse;\n    };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n    var getInUseByOperationName = makeInUseGetterFunction(\"\");\n    var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n    var getInUse = function (ancestors) {\n        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n            if (isArray(ancestor))\n                continue;\n            if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\n            }\n            if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n                return getInUseByFragmentName(ancestor.name.value);\n            }\n        }\n        __DEV__ && invariant.error(\"Could not find operation or fragment\");\n        return null;\n    };\n    var operationCount = 0;\n    for (var i = doc.definitions.length - 1; i >= 0; --i) {\n        if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n            ++operationCount;\n        }\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var hasRemoveDirective = directives.some(function (directive) { return directive.remove; });\n    var shouldRemoveField = function (nodeDirectives) { return (hasRemoveDirective &&\n        nodeDirectives &&\n        nodeDirectives.some(directiveMatcher)); };\n    var originalFragmentDefsByPath = new Map();\n    var firstVisitMadeChanges = false;\n    var fieldOrInlineFragmentVisitor = {\n        enter: function (node) {\n            if (shouldRemoveField(node.directives)) {\n                firstVisitMadeChanges = true;\n                return null;\n            }\n        },\n    };\n    var docWithoutDirectiveSubtrees = visit(doc, {\n        Field: fieldOrInlineFragmentVisitor,\n        InlineFragment: fieldOrInlineFragmentVisitor,\n        VariableDefinition: {\n            enter: function () {\n                return false;\n            },\n        },\n        Variable: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.variables.add(node.name.value);\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                if (shouldRemoveField(node.directives)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.fragmentSpreads.add(node.name.value);\n                }\n            },\n        },\n        FragmentDefinition: {\n            enter: function (node, _key, _parent, path) {\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\n            },\n            leave: function (node, _key, _parent, path) {\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n                if (node === originalNode) {\n                    return node;\n                }\n                if (operationCount > 0 &&\n                    node.selectionSet.selections.every(function (selection) { return (selection.kind === Kind.FIELD &&\n                        selection.name.value === '__typename'); })) {\n                    getInUseByFragmentName(node.name.value).removed = true;\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n        Directive: {\n            leave: function (node) {\n                if (directiveMatcher(node)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n    });\n    if (!firstVisitMadeChanges) {\n        return doc;\n    }\n    var populateTransitiveVars = function (inUse) {\n        if (!inUse.transitiveVars) {\n            inUse.transitiveVars = new Set(inUse.variables);\n            if (!inUse.removed) {\n                inUse.fragmentSpreads.forEach(function (childFragmentName) {\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n                        inUse.transitiveVars.add(varName);\n                    });\n                });\n            }\n        }\n        return inUse;\n    };\n    var allFragmentNamesUsed = new Set();\n    docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n        if (def.kind === Kind.OPERATION_DEFINITION) {\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n                allFragmentNamesUsed.add(childFragmentName);\n            });\n        }\n        else if (def.kind === Kind.FRAGMENT_DEFINITION &&\n            operationCount === 0 &&\n            !getInUseByFragmentName(def.name.value).removed) {\n            allFragmentNamesUsed.add(def.name.value);\n        }\n    });\n    allFragmentNamesUsed.forEach(function (fragmentName) {\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n            allFragmentNamesUsed.add(childFragmentName);\n        });\n    });\n    var fragmentWillBeRemoved = function (fragmentName) { return !!(!allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed); };\n    var enterVisitor = {\n        enter: function (node) {\n            if (fragmentWillBeRemoved(node.name.value)) {\n                return null;\n            }\n        },\n    };\n    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n        FragmentSpread: enterVisitor,\n        FragmentDefinition: enterVisitor,\n        OperationDefinition: {\n            leave: function (node) {\n                if (node.variableDefinitions) {\n                    var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\n                        return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) { return usedVariableNames_1.has(varDef.variable.name.value); }) });\n                    }\n                }\n            },\n        },\n    }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n    return visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                if (parent &&\n                    parent.kind === Kind.OPERATION_DEFINITION) {\n                    return;\n                }\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === '__typename' ||\n                            selection.name.value.lastIndexOf('__', 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === 'export'; })) {\n                    return;\n                }\n                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n            },\n        },\n    });\n}, {\n    added: function (field) {\n        return field === TYPENAME_FIELD;\n    },\n});\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === 'connection';\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {\n                __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' +\n                    'You may want to use the key parameter to specify a store key.');\n            }\n        }\n        return willRemove;\n    },\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (!!selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!isField(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === Kind.VARIABLE &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                    }) : [] });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\nexport function buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === 'query') {\n        return document;\n    }\n    var modifiedDoc = visit(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { operation: 'query' });\n            },\n        },\n    });\n    return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === 'client'; },\n            remove: true,\n        },\n    ], document);\n    return modifiedDoc;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}