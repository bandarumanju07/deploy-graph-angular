{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nvar defaultMakeData = function () {\n  return Object.create(null);\n};\n// Useful for processing arguments objects as well as arrays.\nvar _a = Array.prototype,\n  forEach = _a.forEach,\n  slice = _a.slice;\nvar Trie = /** @class */function () {\n  function Trie(weakness, makeData) {\n    if (weakness === void 0) {\n      weakness = true;\n    }\n    if (makeData === void 0) {\n      makeData = defaultMakeData;\n    }\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n  Trie.prototype.lookup = function () {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i] = arguments[_i];\n    }\n    return this.lookupArray(array);\n  };\n  Trie.prototype.lookupArray = function (array) {\n    var node = this;\n    forEach.call(array, function (key) {\n      return node = node.getChildTrie(key);\n    });\n    return node.data || (node.data = this.makeData(slice.call(array)));\n  };\n  Trie.prototype.getChildTrie = function (key) {\n    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());\n    var child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  };\n  return Trie;\n}();\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n    case \"function\":\n      return true;\n  }\n  return false;\n}\nexport { Trie };","map":{"version":3,"names":["defaultMakeData","Object","create","_a","Array","prototype","forEach","slice","Trie","weakness","makeData","lookup","array","_i","arguments","length","lookupArray","node","call","key","getChildTrie","data","map","isObjRef","weak","WeakMap","strong","Map","child","get","set","value"],"sources":["/Users/manjunathbandaru/deploy-graph-angular/node_modules/@wry/trie/lib/trie.esm.js"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\r\n// object keys weakly, yet can also hold non-object keys, unlike the\r\n// native `WeakMap`.\r\n// If no makeData function is supplied, the looked-up data will be an empty,\r\n// null-prototype Object.\r\nvar defaultMakeData = function () { return Object.create(null); };\r\n// Useful for processing arguments objects as well as arrays.\r\nvar _a = Array.prototype, forEach = _a.forEach, slice = _a.slice;\r\nvar Trie = /** @class */ (function () {\r\n    function Trie(weakness, makeData) {\r\n        if (weakness === void 0) { weakness = true; }\r\n        if (makeData === void 0) { makeData = defaultMakeData; }\r\n        this.weakness = weakness;\r\n        this.makeData = makeData;\r\n    }\r\n    Trie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    Trie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        forEach.call(array, function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = this.makeData(slice.call(array)));\r\n    };\r\n    Trie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new Trie(this.weakness, this.makeData));\r\n        return child;\r\n    };\r\n    return Trie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\nexport { Trie };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,eAAe,GAAG,YAAY;EAAE,OAAOC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAAE,CAAC;AACjE;AACA,IAAIC,EAAE,GAAGC,KAAK,CAACC,SAAS;EAAEC,OAAO,GAAGH,EAAE,CAACG,OAAO;EAAEC,KAAK,GAAGJ,EAAE,CAACI,KAAK;AAChE,IAAIC,IAAI,GAAG,aAAe,YAAY;EAClC,SAASA,IAAI,CAACC,QAAQ,EAAEC,QAAQ,EAAE;IAC9B,IAAID,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,IAAI;IAAE;IAC5C,IAAIC,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAGV,eAAe;IAAE;IACvD,IAAI,CAACS,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC5B;EACAF,IAAI,CAACH,SAAS,CAACM,MAAM,GAAG,YAAY;IAChC,IAAIC,KAAK,GAAG,EAAE;IACd,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CD,KAAK,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC7B;IACA,OAAO,IAAI,CAACG,WAAW,CAACJ,KAAK,CAAC;EAClC,CAAC;EACDJ,IAAI,CAACH,SAAS,CAACW,WAAW,GAAG,UAAUJ,KAAK,EAAE;IAC1C,IAAIK,IAAI,GAAG,IAAI;IACfX,OAAO,CAACY,IAAI,CAACN,KAAK,EAAE,UAAUO,GAAG,EAAE;MAAE,OAAOF,IAAI,GAAGA,IAAI,CAACG,YAAY,CAACD,GAAG,CAAC;IAAE,CAAC,CAAC;IAC7E,OAAOF,IAAI,CAACI,IAAI,KAAKJ,IAAI,CAACI,IAAI,GAAG,IAAI,CAACX,QAAQ,CAACH,KAAK,CAACW,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC;EACtE,CAAC;EACDJ,IAAI,CAACH,SAAS,CAACe,YAAY,GAAG,UAAUD,GAAG,EAAE;IACzC,IAAIG,GAAG,GAAG,IAAI,CAACb,QAAQ,IAAIc,QAAQ,CAACJ,GAAG,CAAC,GAClC,IAAI,CAACK,IAAI,KAAK,IAAI,CAACA,IAAI,GAAG,IAAIC,OAAO,EAAE,CAAC,GACxC,IAAI,CAACC,MAAM,KAAK,IAAI,CAACA,MAAM,GAAG,IAAIC,GAAG,EAAE,CAAC;IAC9C,IAAIC,KAAK,GAAGN,GAAG,CAACO,GAAG,CAACV,GAAG,CAAC;IACxB,IAAI,CAACS,KAAK,EACNN,GAAG,CAACQ,GAAG,CAACX,GAAG,EAAES,KAAK,GAAG,IAAIpB,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,QAAQ,CAAC,CAAC;IAChE,OAAOkB,KAAK;EAChB,CAAC;EACD,OAAOpB,IAAI;AACf,CAAC,EAAG;AACJ,SAASe,QAAQ,CAACQ,KAAK,EAAE;EACrB,QAAQ,OAAOA,KAAK;IAChB,KAAK,QAAQ;MACT,IAAIA,KAAK,KAAK,IAAI,EACd;IACR;IACA,KAAK,UAAU;MACX,OAAO,IAAI;EAAC;EAEpB,OAAO,KAAK;AAChB;AAEA,SAASvB,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}